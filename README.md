# Algorithm use Python
:shipit: :shipit: :shipit:
#### 大O复杂度分析
一般法则
* 法则1--for循环
+ 一次for循环的运行时间至多是该for循环内语句（包括测试）的运行时间乘以迭代次数。
* 法则2--嵌套for循环
+ 从里向外分析这些循环。在一组嵌套循环内部的一条语句总的运行时间为该语句的运行时间乘以该组所有的for循环的大小的乘积。作为一个例子，下列程序片段为O(N方)：
'''
def foo():
    for i < n:
        for j < n:
'''
#### 排序: 快速排序、归并排序
#### 哈希表
#### 树：遍历（BFS/DFS）前序中序后序，构造
* 二叉树
* n叉树
* trie树
* 平衡二叉树：红黑树、伸展树、AVL树
#### 图：（对象和指针、矩阵、邻接表）
> 每次遇到问题，首先应当考虑图算法。它是任何关系最基本、最灵活的表示方法，任何有点意思的设计问题可以说有一半的机会涉及图算法。只有在你百分百确定没办法用图算法来解决的时候，才考虑其他方案。:+1:
[Link to Google](www.google.com)
* 广度优先搜索
* 深度优先搜索
* Dijkstra 狄克斯特拉算法：加权图、有向无环图
1. 找出“最便宜”的节点，即在最短时间内到达的节点。
2. 更新该节点的邻居的开销，其含义将稍后介绍。
3. 重复这个过程，直到对图中的每个节点都这样做了。
4. 计算最终路径。
**相关术语**
狄克斯特拉算法用于每条边都有关联数字的图，这些数字称为权重(weight)。
带权重的图称为加权图(weighted graph)，不带权重的图称为非加权图(unweighted graph)。
要计算非加权图中的最短路径，可使用广度优先搜索。要计算加权图中的最短路径，可使用狄克斯特拉算法。
狄克斯特拉算法只适用于有向无环图(directed acyclic graph, DAG)
#### A*算法



